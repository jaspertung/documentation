<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>React</h1>
    <nav>
        <ul>
            <li><a href="#objects">Objects and JS Classes</a></li>
            <li><a href="#array-methods">Advanced Array Methods</a></li>
            <li><a href="#">_</a> </li>
            <li><a href="#">_</a> </li>
        </ul>
    </nav>

    <!-- objects and classes -->
    <h2>Objects and JS Classes</h2>
        <ul>
        <li>Objects are 1 of the 8 JS data types</li>
        </ul>
        <h3>Objects</h3>
            <ul>
                <li>only data type that isn't a primitive</li>
                <li>data structure for a collection of data</li>
                <li>can have properties and methods (variables and functions that "belong" to that object"</li>
                <li>const objectName = {<br>name1: "value1",<br>name2: "value2"<br>}</li>
            </ul>
            <h4>Object Methods</h4>
                <ul>
                    <li>can add custom methods to objects (unlike arrays which have predefined methods)</li>
                    <ul>
                        <li>const objectName = {<br>name1: "value1",<br>name2: "value2"<br>name3() {<br>console.log(`value3`)<br>}<br>}</li>
                    </ul>
                </ul>
            <h4>Add and update object properties and methods</h4>
                <ul>
                    <li>add properties</li>
                    <ul>
                        <li>objectName.name3 = "value3"</li>
                    </ul>
                    <li>update properties</li>
                    <ul>
                        <li>objectName.name1 = "firstValue"</li>
                    </ul>
                    <li>add methods</li>
                    <ul>
                        <li>objectName.name4 = function() {<br>console.log(`value4`)<br>}</li>
                    </ul>
                    <li>update methods</li>
                    <ul>
                        <li>objectName.name3 = function() {<br>console.log(`thirdValue`)<br>}</li>
                    </ul>
                </ul>
            <h4>Object Constants</h4>
                <ul>
                    <li>even if declare object variable with const keyword, properties and methods can be changed, but not the variable itself</li>
                </ul>
            <h4>Method parameters</h4>
                <ul>
                    <li>objectName.name3 = function(string) {<br>console.log(`insert ${string}`)<br>}</li>
                    <li>objectName.name3(`Hello World`)</li>
                    <li>will log: insert Hello World</li>
                </ul>
        <h3>This keyword</h3>
            <ul>
                <li>keyword refers to the object it belongs to to get different values</li>
                <li>Example</li>
                <ul>
                    <li>const dragon1 = {<br>color: `red`,<br>roar() {<br>console.log(`big ${this.color} roar`)<br>}<br>}<br>logs big red roar</li>
                </ul>
            </ul>
        <h3>JS Classes</h3>
            <ul>
            <li>templates for objects to create multiple instances of the same kind of object</li>
            <li>must have class keyword</li>
            <li>class name must start with capital letter</li>
            <li>only 1 constructor for a class and can leave out if no default properties</li>
            <li>Syntax</li>
            <ul>
                <li>class ClassName {<br>constructor(param1, param2) {<br>this.param1 = arg1<br>this.param2 = arg2<br>}<br>}</li>
            </ul>
            <li>Create object variables using JS classes</li>
            <ul>
                <li>const variable = new ClassName(arg1, arg2)</li>
                <li>create object ClassName {param1: arg1, param2: arg2}</li>
            </ul>
            <li>Example</li>
            <ul>
                <li>class Dragon {<br>constructor(color, maxHP) {<br>this.color = color<br>this.maxHP = maxHP<br>}<br>}</li>
                <li>const dragon1 = new Dragon(`red`, 2000)</li>
                <li>object dragon1 {color: `red`, maxHP: 2000)</li>
            </ul>
            </ul>
            <h4>Class Methods</h4>
                <ul>
                <li>can use this keyword to refer to the properties of the object without having the object name</li>
                </ul>
        <h3>Class Inheritance</h3>
            <ul>
            <li>can create child classes based on parent classes</li>
            <li>child class will inherit properties and methods of parent class but not vice versa</li>
            <li>child class can add its own properties and methods without affecting the parent class</li>
            <li>use extends keyword</li>
            <li>Syntax</li>
            <ul>
                <li>use JS class to create parent class</li>
                <li>then for child class use class ChildName extends ParentName {}</li>
            </ul>
            <li>Example</li>
            <ul>
                <li>create parent Monster class and child Dragon class -&gt; variables created with Dragon will have its own properties plus parent's, but variables created with Monster will only have its own properties</li>
            </ul>
            </ul>
            <h4>Super method</h4>
                <ul>
                <li>putting super in child class lets you use properties from the parent class</li>
                <li>usually need to have this.color or this.type, but can use super(color, type)</li>
                </ul>
        <h3>Default Function Parameters</h3>
            <ul>
            <li>if set parameters and don't provide arguments, JS will set to default undefined</li>
            <li>Example</li>
            <ul>
                <li>function logSum(a = 0, b = 0) {<br>console.log(a + b)<br>}</li>
                <li>logSum(2) will log 2 + 0 or 2</li>
            </ul>
            <li>can also set defaults for constructor parameters in JS classes</li>
            <ul>
                <li>constructor(color = `blue`, maxHP = `1000`)</li>
            </ul>
            </ul>
    
    <!-- advanced array methods -->
    <h2 id="array-methods">Advanced Array Methods</h2>
        <ul>
        <li>possible to pass a function into another function as an argument</li>
        <li>higher order function: function that takes another function as an argument or returns a function as a return value</li>
        <ul>
            <li>ex. map, filter, reduce</li>
        </ul>
        <li>callback function: function that's passed into a higher order function as an argument, then used/called back inside it</li>
        <ul>
            <li>usually in the form of an arrow function</li>
        </ul>
        <li>map, filter, and reduce</li>
        <ul>
            <li>take callback functions as arguments</li>
            <li>none are mutator methods, but are all iteration methods</li>
            <li>all have return values</li>
            <ul>
                <li>map and filter: return a new array</li>
                <li>reduce: return a single value (not an array)</li>
            </ul>
        </ul>
        </ul>
        <h3>Map</h3>
            <ul>
            <li>iterates through an array and performs a given callback function on every item in the array</li>
            <li>const array = [2, 4, 8, 45]<br>const arrayMap = array.map(n => n * 2)<br>arrayMap = [4, 8, 16, 90]</li>
            <li>callback function has parameter n to stand for number (auto iterates from beginning to end of array)</li>
            </ul>
        <h3>Filter</h3>
            <ul>
            <li>takes a callback function that specifies a filtering condition, iterates through an array, and returns a new array with items considered true</li>
            <li>const array = [2, 4, 8, 45]<br>const arrayFilter = array.filter(n => n &lt; 10)<br>arrayFilter = [2, 4, 8]</li>
            </ul>
        <h3>Reduce</h3>
            <ul>
            <li>takes an array and reduces it to a single value</li>
            <li>const array = [2, 4, 8, 45]<br>const reducedValue = array.reduce((a, c) => a + b)<br>reducedValue = 59</li>
            <li>a: accumulator (running total) &amp; c: current value (iterator)</li>
            <li>can set parameter to be intial value of accumulator</li>
            <ul>
                <li>if don't set, accumulator will default be first item in array and current value the second</li>
                <li>if working with array of objects, then need to set initial value</li>
            </ul>
            </ul>
        <h3>Arrays of Objects</h3>
            <ul>
            <li>in array, define objects using object literals (part inside {}) without assigning each one to a variable name</li>
            <li>const desserts = [<br>{<br>id: 0,<br>flavor: `chocolate`,<br>cost: 2.50<br>},<br>{<br>id: 1,<br>flavor: `vanilla`,<br>cost: 4.00<br>}<br>]</li>
            <li>filter example</li> 
            <ul>
                <li>const filteredDessert = desserts.filter(dessert => dessert.flavor === `vanilla`)</li>
                <li>filteredDessert = [{id: 1, cost: 4.00, flavor: `vanilla`}]</li>
            </ul>
            <li>reduce example</li>
            <ul>
                <li>const totalCost = desserts.reduce((total, dessert) => total + dessert.cost, 0)</li>
                <li>totalCost = 6.50</li>
                <li>need to have default value of 0 or else will use the entire object and not just the specific property (dessert.cost)</li>
            </ul>
            </ul>
        <h3>Method Chaining</h3>
            <ul>
            <li>running multiple methods in a single statement through return values (return values required for chaining)</li>
            <li>array method chaining</li>
            <ul>
                <li>const array = [2, 4, 8, 45]<br>const chainedArray = array.map(n => n * 2).filter(n => n &lt; 10)<br>chainedArray = [4, 8]</li>
                <li>some built-in methods already have built-in return values</li>
            </ul>
            <li>object method chaining</li>
            <ul>
                <li>const dragon1 = {<br>roar() {<br>console.log(`dragon roar`),<br>return this<br>},<br>fly() {<br>console.log(`dragon fly`)<br>}<br>}<br>dragon1.roar().fly() logs dragon roar &amp; dragon fly</li>
                <li>only works because roar() has return value of this</li>
                <li>when writing own custom methods, must return value yourself</li>
            </ul>
            </ul>

    <!-- intro to react -->
    <h2>Intro to React</h2>
        <ul>
            <li>libraries: you call the library when you want to use it (ex. react, jquery)</li>
            <li>frameworks: framework has control and calls your code when needed (ex. angular)</li>
            <li>Defining features of React</li>
            <ul>
                <li>declarative approach over imperative approach</li>
                <ul>
                    <li>declarative: declare what you want to see, then React updates DOM</li>
                    <li>imperative: manipulate the DOM directly yourself</li>
                </ul>
                <li>component-based approach: groups UI into components</li>
                <li>plays well with other technologies: only focuses on the UI and lets you decide the rest of the application architecture</li>
            </ul>
        </ul>
        <h3>Intro to JSX</h3>
            <ul>
                <li>syntactic extension to JS to help write front-end code faster</li>
                <li>preprocessor language for JS (like Sass for CSS) that lets you write HTML in JS and it will be compiled into regular JS for the browser</li>
                <li>instead of JS: document.createElement() or React: React.createElement()</li>
                <li>can use React with JSX &lt;div&gt;Hello World!&lt;/div&gt;</li>
                <li>differences</li>
                <ul>
                    <li>className instead of class &amp; htmlFor instead of for</li>
                    <li>if element has no content, can write it as a self-closing tag</li>
                    <ul>
                        <li>ex. instead of &lt;i className="fa fa-phone"&gt;&lt;/i&gt; can use &lt;i className="fa fa-phone"&gt;</li>
                    </ul>
                    <li>can embed JS expressions using {}</li>
                </ul>
            </ul>
        <h3>Initial Configuration</h3>
            <ul>
                <li>add Reactstrap (for React based Bootstrap components) and Bootstrap (jquery and popper)</li>
                <li>in React components: syntax looks like HTML/JSX tags (&lt;&gt;) that start with capital letter are components (ex. Navbar) and lower case ones are JSX elements (ex. className)</li>
            </ul>
        <h3>JS import and export</h3>
            <ul>
                <li>import and export keywords let files share data with each other (data can be objects, primitives, and functions (including classes)</li>
                <li>2 kinds of exports: named- can have many in a file, default- can only have 1</li>
                <ul>
                    <li>default: export default App; import App from './App';</li>
                    <li>named: export { App }; import { App } from './App';</li>
                </ul>
                <li>JS module- file has at least 1 export</li>
            </ul>
    
    <!-- React components -->
    <h2>React Components</h2>
        <ul>
            <li>components: have &lt;/&gt; and start with capital letter</li>
            <li>can think of components like functions (repeatable blocks of code that need to be defined then called) for components, we define then render</li>
            <li>defining react components</li>
            <ul>
                <li>functional component: shorter and simpler compared to class components, but with different syntax and some differences</li>
                <ul>
                    <li>need to have capitalized name, accepts props as an argument, no constructor or render methods, can't use lifecycle methods or hold state (without hooks), and don't need this. for this.props</li>
                    <li>function Example(props) {<br>return &lt;div&gt;{props.someData}&lt;/div&gt;;<br>}</li>
                </ul>
                <li>class component: creating child class of parent Component (from React library)</li>
                <ul>
                    <li>class Example extends Component {<br>render() {<br>return &lt;div&gt;{this.props.someData}&lt;/div&gt;<br>}<br>}</li>
                </ul>
            </ul>
            <li>rendering components</li>
            <ul>
                <li>render like an HTML tag with first letter capitalized and typically, but not always, self-closing (custom components)</li>
                <li>ex. &lt;Navbar&gt;&lt;/Navbar&gt; OR &lt;App /&gt;</li>
            </ul>
            <li>why use components?</li>
            <ul>
                <li>easily compose UI in modular way, like Bootstrap but can make own custom components or use 3rd party component libraries</li>
            </ul>
            <li>basic structure of class component</li>
            <ul>
                <img src="img/react-class-structure.png" alt="">
                <li>if a class has local state, it must have a constructor</li>
                <li>if a class has a constructor (optional), it must include props (short for properties) as an argument and use super(props) to inherit from parent class</li>
                <li>components always return a single object (JSX element or another component)</li>
            </ul>
            <li>to render an array of elements most efficiently, add a unique key attribute to the topmost element in each array item</li>
            <ul>
                <li>key={this.id}</li>
            </ul>
            <li>lifting state up: put state higher up in component hierarchy so multiple components have access to the same read only data (use prop from parent)</li>
            <li>use React.fragment or empty &lt;&gt;&lt;/&gt; (not supported everywhere) instead of div when returning only 1 element to prevent an extra unnecessary DOM node</li>
        </ul>
        <h3>State and Props</h3>
            <ul>
                <li>components can have 2 kinds of data</li>
                <ul>
                    <li>state data: stored locally within the component itself (can be changed)</li>
                    <li>prop data: stored in a parent component and passed down (read-only)</li>
                </ul>
                <li>to pass data out of a component, include the data as a custom attribute (ex.number) when rendering the component in another component</li>
                <li>state: class components can define a this.state object in constructor method to hold data for the component to use or pass down to child components as props</li>
                <ul>
                    <li>should never be assigned anywhere except in constructor, if elsewhere, use this.setState method to change</li>
                </ul>
                <li>props: objects in React used by components to receive data from parent components</li>
                <li>can pass multiple props to render (ex.greeting)</li>
                <img src="img/react-state-and-props.png" alt="">
            </ul>
    <h2>Object Destructuring</h2>
        <ul>
            <li>shortcut for accessing properties inside objects or items inside arrays then assigning them as values of new variables</li>
            <li>syntax</li>
            <ul>
                <li>const {property1, property2} = someObject</li>
                <li>function someFunction({property1, property2}) {}</li>
            </ul>
            <li>example 1</li>
            <ul>
                <li>const hotel = {<br> id: 0,<br>city: "Honolulu"<br>}</li>
                <li>instead of:</li>
                <li>const id = hotel.id<br>const city = hotel.city</li>
                <li>can use:</li>
                <li>const {id, city} = hotel</li>
            </ul>
            <li>example 2</li>
            <ul>
                <li>instead of:</li>
                <li>function hotelInfo(hotel) {<br>const id = hotel.id<br>const city = hotel.city<br>console.log(`${hotel.id} ${hotel.city}`)<br>}</li>
                <li>can use:</li>
                <li>function hotelInfo({id, city}) {<br>console.log(`${hotel.id} ${hotel.city}`)<br>}</li>
            </ul>
        </ul>
    <h2>React Component Types</h2>
        <ul>
            <li>Presentational and Container Components</li>
                <ul>
                    <li>presentational: renders UI based on props passed to them (don't usually maintain their own state beyond some light UI state)</li>
                    <li>container: fetches and manages state data to pass to presentational components for rendering</li>
                </ul>
        </ul>
    <h2>React Router</h2>
        <h3>React Virtual DOM</h3>
            <ul>
                <li>Browser DOM</li>
                <ul>
                    <li>the DOM is an API (application programming interface)- set of specifications for how programming languages and HTML interact with each other</li>
                    <li>maps HTML elements to a node-based, tree-like representation that programming languages can understand, traverse, and modify</li>
                    <li>when browser DOM is recreated, graphical view re-renders every time, so process can be "expensive"</li>
                </ul>
                <li>Virtual DOM</li>
                <ul>
                    <li>React is 1 implementation of the virtual DOM technique</li>
                    <li>React maintains a lightweight representation of the browser DOM which is faster and easier to update plus doesn't re-render the graphical display</li>
                    <li>DOM changes are first made in the virtual DOM</li>
                    <li>reconciliation (engine: Fiber): finds differences between virtual and browser DOM then finds best way to change the browser DOM</li>
                    <li>the reason why we use setState to change the state rather than changing it directly</li>
                    <li>the reason we use key attributes on list elements: helps reconciliation process</li>
                </ul>
            </ul>
        <h3>React Router</h3>
            <ul>
                <li>can use React to built a Single Page App (SPA) which launches from a single HTML page instead of having multiple HTML pages</li>
                <li>React Router- routing library that includes collection of router, route matching, and navigation components</li>
                <ul>
                    <li>handles routing requests to navigate to different views</li>
                    <li>generates unique, bookmarkable URL for each view</li>
                    <li>handles browser history (ability to move back and forward)</li>
                </ul>
                <li>react router components</li>
                <ul>
                    <li>&lt;BrowserRouter/&gt; top-level parent component that wraps around all other React-Router components (uses HTML5 history API to control browser history)</li>
                    <li>&lt;Route/&gt; renders UI for a matching path (use the attribute exact to get an exact match</li>
                    <ul>
                        <li>If just routing to component without passing state datea, use component={}</li>
                        <li>if need to pass state data as props to the component you're routing to, use render={}</li>
                    </ul>
                    <li>&lt;Redirect/&gt; redirects to a new URL</li>
                    <li>&lt;Switch/&gt; groups &lt;Route/&gt; components together</li>
                    <ul>
                        <li>works like switch from JS, will look through each case (route path) and if there is no match, then go to default (redirect)</li>
                    </ul>
                    <li>&lt;Link/&gt; creates links to a path (use instead of &lt;a&gt;)</li>
                    <li>&lt;Navlink/&gt; version of &lt;Link/&gt; that adds styles to active link</li>
                </ul>
            </ul>
        <h2>Single Page Application (SPA)</h2>
            <ul>
                <li>multi-page website: code is re-rendered and new server request every time you go to a new page</li>
                <li>SPA: front-end code is locally downloaded, when switching views app re-renders only changes and makes minimal server requests (ex. database data)</li>
                <ul>
                    <li>PROS: faster because less server requests, streamlined development, can reuse back end code for mobile app, easy to debug in browser</li>
                    <li>CONS: search engines can have trouble indexing, dependent on JS being enabled in browser, intial download can be slow, does not use traditional browser navigation (need React Router)</li>
                </ul>
            </ul>
        <h2>JS ES6 Computed Property Names, Spread Syntax, and Ternary Operator</h2>
            <ul>
                <li>computed property names: can pass in variables to use as property names when initializing an object (can create objects dynamically)</li>
                <li>example</li>
                <pre>
                    const myProperty = `foo`
                    const myObject = {
                        [myProperty] = `test`
                    }
                    myObject = {foo: `test`}
                </pre>
            </ul>
            <ul>
                <li>spread syntax: use to pull out/spread a copy of what is inside an array or object (can be used to create a new array or object)</li>
                <li>combining 2 arrays</li>
                <pre>
                    const arr1 = [`red`, 1];
                    const arr2 = [`blue`, 3];
                    const arr1and2 = [...arr1, ...arr2];
                    arr1and2 = [`red`, 1, `blue`, 3]
                </pre>
                <li>combining string to array</li>
                <pre>
                    const arr3 = [...arr1, `purple`];
                    arr3 = [`red`, 1, `purple`];
                </pre>
                <li>combining 2 objects (order it is combined matters)</li>
                <pre>
                    const obj1 = { color: `red`, width: 1 };
                    const obj2 = { color: `blue`, height: 3 };
                    const obj1and2 = { ...obj1, ...obj2 };
                    obj1and2 = { color: `blue`, width: 1, height: 3 }
                </pre>
            </ul>
            <ul>
                <li>ternary operator: shortcut for <code>if statement</code></li>
                <li><code>condition ? expression if truthy : expression if falsy</code></li>
                <pre>
                    function canVote(age) {
                        if (age >= 18) {
                            console.log(`can vote`)
                        } else {
                            console.log(`can not vote`)
                        }
                    }
                </pre>
                <pre>
                    function canVote(age)
                        age >= 18 ? console.log(`can vote`) : console.log(`can not vote`)
                </pre>
            </ul>
        <h2>React Forms</h2>
            <h3>Controlled Forms</h3>
                <ul>
                    <li>HTML form values directly tied to the state of its React component</li>
                    <li>single source of truth: React controls the form state to prevent conflicts</li>
                    <li>any changes to form fields immediately reflected in component's state and can be responded to with JS (ex. form validation and error messages)</li>
                    <li>require a lot of initial setup</li>
                </ul>
            <h3>Uncontrolled Forms</h3>
                <ul>
                    <li>HTML form states are tracked by the DOM and React retrieves data as needed</li>
                    <li>single source of truth: form elements within the DOM</li>
                    <li>alternative to controlled forms with quicker setup and easier if integrating React code with non-React code</li>
                    <li>use <code>ref</code>s to retrieve data or in Reactstrap- <code>innerRef</code></li>
                </ul>
</body>
</html>