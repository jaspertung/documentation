<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>React</h1>
    <nav>
        <ul>
            <li><a href="#objects">Objects and JS Classes</a></li>
            <li><a href="#array-methods">Advanced Array Methods</a></li>
            <li><a href="#">_</a> </li>
            <li><a href="#">_</a> </li>
        </ul>
    </nav>

    <!-- objects and classes -->
    <h2>Objects and JS Classes</h2>
        <ul>
        <li>Objects are 1 of the 8 JS data types</li>
        </ul>
        <h3>Objects</h3>
            <ul>
                <li>only data type that isn't a primitive</li>
                <li>data structure for a collection of data</li>
                <li>can have properties and methods (variables and functions that "belong" to that object"</li>
                <li>const objectName = {<br>name1: "value1",<br>name2: "value2"<br>}</li>
            </ul>
            <h4>Object Methods</h4>
                <ul>
                    <li>can add custom methods to objects (unlike arrays which have predefined methods)</li>
                    <ul>
                        <li>const objectName = {<br>name1: "value1",<br>name2: "value2"<br>name3() {<br>console.log(`value3`)<br>}<br>}</li>
                    </ul>
                </ul>
            <h4>Add and update object properties and methods</h4>
                <ul>
                    <li>add properties</li>
                    <ul>
                        <li>objectName.name3 = "value3"</li>
                    </ul>
                    <li>update properties</li>
                    <ul>
                        <li>objectName.name1 = "firstValue"</li>
                    </ul>
                    <li>add methods</li>
                    <ul>
                        <li>objectName.name4 = function() {<br>console.log(`value4`)<br>}</li>
                    </ul>
                    <li>update methods</li>
                    <ul>
                        <li>objectName.name3 = function() {<br>console.log(`thirdValue`)<br>}</li>
                    </ul>
                </ul>
            <h4>Object Constants</h4>
                <ul>
                    <li>even if declare object variable with const keyword, properties and methods can be changed, but not the variable itself</li>
                </ul>
            <h4>Method parameters</h4>
                <ul>
                    <li>objectName.name3 = function(string) {<br>console.log(`insert ${string}`)<br>}</li>
                    <li>objectName.name3(`Hello World`)</li>
                    <li>will log: insert Hello World</li>
                </ul>
        <h3>This keyword</h3>
            <ul>
                <li>keyword refers to the object it belongs to to get different values</li>
                <li>Example</li>
                <ul>
                    <li>const dragon1 = {<br>color: `red`,<br>roar() {<br>console.log(`big ${this.color} roar`)<br>}<br>}<br>logs big red roar</li>
                </ul>
            </ul>
        <h3>JS Classes</h3>
            <ul>
            <li>templates for objects to create multiple instances of the same kind of object</li>
            <li>must have class keyword</li>
            <li>class name must start with capital letter</li>
            <li>only 1 constructor for a class and can leave out if no default properties</li>
            <li>Syntax</li>
            <ul>
                <li>class ClassName {<br>constructor(param1, param2) {<br>this.param1 = arg1<br>this.param2 = arg2<br>}<br>}</li>
            </ul>
            <li>Create object variables using JS classes</li>
            <ul>
                <li>const variable = new ClassName(arg1, arg2)</li>
                <li>create object ClassName {param1: arg1, param2: arg2}</li>
            </ul>
            <li>Example</li>
            <ul>
                <li>class Dragon {<br>constructor(color, maxHP) {<br>this.color = color<br>this.maxHP = maxHP<br>}<br>}</li>
                <li>const dragon1 = new Dragon(`red`, 2000)</li>
                <li>object dragon1 {color: `red`, maxHP: 2000)</li>
            </ul>
            </ul>
            <h4>Class Methods</h4>
                <ul>
                <li>can use this keyword to refer to the properties of the object without having the object name</li>
                </ul>
        <h3>Class Inheritance</h3>
            <ul>
            <li>can create child classes based on parent classes</li>
            <li>child class will inherit properties and methods of parent class but not vice versa</li>
            <li>child class can add its own properties and methods without affecting the parent class</li>
            <li>use extends keyword</li>
            <li>Syntax</li>
            <ul>
                <li>use JS class to create parent class</li>
                <li>then for child class use class ChildName extends ParentName {}</li>
            </ul>
            <li>Example</li>
            <ul>
                <li>create parent Monster class and child Dragon class -&gt; variables created with Dragon will have its own properties plus parent's, but variables created with Monster will only have its own properties</li>
            </ul>
            </ul>
            <h4>Super method</h4>
                <ul>
                <li>putting super in child class lets you use properties from the parent class</li>
                <li>usually need to have this.color or this.type, but can use super(color, type)</li>
                </ul>
        <h3>Default Function Parameters</h3>
            <ul>
            <li>if set parameters and don't provide arguments, JS will set to default undefined</li>
            <li>Example</li>
            <ul>
                <li>function logSum(a = 0, b = 0) {<br>console.log(a + b)<br>}</li>
                <li>logSum(2) will log 2 + 0 or 2</li>
            </ul>
            <li>can also set defaults for constructor parameters in JS classes</li>
            <ul>
                <li>constructor(color = `blue`, maxHP = `1000`)</li>
            </ul>
            </ul>
    
    <!-- advanced array methods -->
    <h2 id="array-methods">Advanced Array Methods</h2>
        <ul>
        <li>possible to pass a function into another function as an argument</li>
        <li>higher order function: function that takes another function as an argument or returns a function as a return value</li>
        <ul>
            <li>ex. map, filter, reduce</li>
        </ul>
        <li>callback function: function that's passed into a higher order function as an argument, then used/called back inside it</li>
        <ul>
            <li>usually in the form of an arrow function</li>
        </ul>
        <li>map, filter, and reduce</li>
        <ul>
            <li>take callback functions as arguments</li>
            <li>none are mutator methods, but are all iteration methods</li>
            <li>all have return values</li>
            <ul>
                <li>map and filter: return a new array</li>
                <li>reduce: return a single value (not an array)</li>
            </ul>
        </ul>
        </ul>
        <h3>Map</h3>
            <ul>
            <li>iterates through an array and performs a given callback function on every item in the array</li>
            <li>const array = [2, 4, 8, 45]<br>const arrayMap = array.map(n => n * 2)<br>arrayMap = [4, 8, 16, 90]</li>
            <li>callback function has parameter n to stand for number (auto iterates from beginning to end of array)</li>
            </ul>
        <h3>Filter</h3>
            <ul>
            <li>takes a callback function that specifies a filtering condition, iterates through an array, and returns a new array with items considered true</li>
            <li>const array = [2, 4, 8, 45]<br>const arrayFilter = array.filter(n => n &lt; 10)<br>arrayFilter = [2, 4, 8]</li>
            </ul>
        <h3>Reduce</h3>
            <ul>
            <li>takes an array and reduces it to a single value</li>
            <li>const array = [2, 4, 8, 45]<br>const reducedValue = array.reduce((a, c) => a + b)<br>reducedValue = 59</li>
            <li>a: accumulator (running total) &amp; c: current value (iterator)</li>
            <li>can set parameter to be intial value of accumulator</li>
            <ul>
                <li>if don't set, accumulator will default be first item in array and current value the second</li>
                <li>if working with array of objects, then need to set initial value</li>
            </ul>
            </ul>
        <h3>Arrays of Objects</h3>
            <ul>
            <li>in array, define objects using object literals (part inside {}) without assigning each one to a variable name</li>
            <li>const desserts = [<br>{<br>id: 0,<br>flavor: `chocolate`,<br>cost: 2.50<br>},<br>{<br>id: 1,<br>flavor: `vanilla`,<br>cost: 4.00<br>}<br>]</li>
            <li>filter example</li> 
            <ul>
                <li>const filteredDessert = desserts.filter(dessert => dessert.flavor === `vanilla`)</li>
                <li>filteredDessert = [{id: 1, cost: 4.00, flavor: `vanilla`}]</li>
            </ul>
            <li>reduce example</li>
            <ul>
                <li>const totalCost = desserts.reduce((total, dessert) => total + dessert.cost, 0)</li>
                <li>totalCost = 6.50</li>
                <li>need to have default value of 0 or else will use the entire object and not just the specific property (dessert.cost)</li>
            </ul>
            </ul>
        <h3>Method Chaining</h3>
            <ul>
            <li>running multiple methods in a single statement through return values (return values required for chaining)</li>
            <li>array method chaining</li>
            <ul>
                <li>const array = [2, 4, 8, 45]<br>const chainedArray = array.map(n => n * 2).filter(n => n &lt; 10)<br>chainedArray = [4, 8]</li>
                <li>some built-in methods already have built-in return values</li>
            </ul>
            <li>object method chaining</li>
            <ul>
                <li>const dragon1 = {<br>roar() {<br>console.log(`dragon roar`),<br>return this<br>},<br>fly() {<br>console.log(`dragon fly`)<br>}<br>}<br>dragon1.roar().fly() logs dragon roar &amp; dragon fly</li>
                <li>only works because roar() has return value of this</li>
                <li>when writing own custom methods, must return value yourself</li>
            </ul>
            </ul>

    <!-- intro to react -->
    <h2>Intro to React</h2>
        <ul>
            <li>libraries: you call the library when you want to use it (ex. react, jquery)</li>
            <li>frameworks: framework has control and calls your code when needed (ex. angular)</li>
            <li>Defining features of React</li>
            <ul>
                <li>declarative approach over imperative approach</li>
                <ul>
                    <li>declarative: declare what you want to see, then React updates DOM</li>
                    <li>imperative: manipulate the DOM directly yourself</li>
                </ul>
                <li>component-based approach: groups UI into components</li>
                <li>plays well with other technologies: only focuses on the UI and lets you decide the rest of the application architecture</li>
            </ul>
        </ul>
        <h3>Intro to JSX</h3>
            <ul>
                <li>syntactic extension to JS to help write front-end code faster</li>
                <li>preprocessor language for JS (like Sass for CSS) that lets you write HTML in JS and it will be compiled into regular JS for the browser</li>
                <li>instead of JS: document.createElement() or React: React.createElement()</li>
                <li>can use React with JSX &lt;div&gt;Hello World!&lt;/div&gt;</li>
                <li>differences</li>
                <ul>
                    <li>className instead of class &amp; htmlFor instead of for</li>
                    <li>if element has no content, can write it as a self-closing tag</li>
                    <ul>
                        <li>ex. instead of &lt;i className="fa fa-phone"&gt;&lt;/i&gt; can use &lt;i className="fa fa-phone"&gt;</li>
                    </ul>
                    <li>can embed JS expressions using {}</li>
                </ul>
            </ul>
        <h3>Initial Configuration</h3>
            <ul>
                <li>add Reactstrap (for React based Bootstrap components) and Bootstrap (jquery and popper)</li>
                <li>in React components: syntax looks like HTML/JSX tags (&lt;&gt;) that start with capital letter are components (ex. Navbar) and lower case ones are JSX elements (ex. className)</li>
            </ul>
        <h3>JS import and export</h3>
            <ul>
                <li>import and export keywords let files share data with each other (data can be objects, primitives, and functions (including classes)</li>
                <li>2 kinds of exports: named- can have many in a file, default- can only have 1</li>
                <ul>
                    <li>default: export default App; import App from './App';</li>
                    <li>named: export { App }; import { App } from './App';</li>
                </ul>
                <li>JS module- file has at least 1 export</li>
            </ul>
    
    <!-- React components -->
    <h2>React Components</h2>
        <ul>
            <li>components: have &lt;/&gt; and start with capital letter</li>
            <li>can think of components like functions (repeatable blocks of code that need to be defined then called) for components, we define then render</li>
            <li>defining react components</li>
            <ul>
                <li>functional component: shorter and simpler compared to class components, but with different syntax and some differences</li>
                <ul>
                    <li>need to have capitalized name, accepts props as an argument, no constructor or render methods, can't use lifecycle methods or hold state (without hooks), and don't need this. for this.props</li>
                    <li>function Example(props) {<br>return &lt;div&gt;{props.someData}&lt;/div&gt;;<br>}</li>
                </ul>
                <li>class component: creating child class of parent Component (from React library)</li>
                <ul>
                    <li>class Example extends Component {<br>render() {<br>return &lt;div&gt;{this.props.someData}&lt;/div&gt;<br>}<br>}</li>
                </ul>
            </ul>
            <li>rendering components</li>
            <ul>
                <li>render like an HTML tag with first letter capitalized and typically, but not always, self-closing (custom components)</li>
                <li>ex. &lt;Navbar&gt;&lt;/Navbar&gt; OR &lt;App /&gt;</li>
            </ul>
            <li>why use components?</li>
            <ul>
                <li>easily compose UI in modular way, like Bootstrap but can make own custom components or use 3rd party component libraries</li>
            </ul>
            <li>basic structure of class component</li>
            <ul>
                <img src="img/react-class-structure.png" alt="">
                <li>if a class has local state, it must have a constructor</li>
                <li>if a class has a constructor (optional), it must include props (short for properties) as an argument and use super(props) to inherit from parent class</li>
                <li>components always return a single object (JSX element or another component)</li>
            </ul>
            <li>to render an array of elements most efficiently, add a unique key attribute to the topmost element in each array item</li>
            <ul>
                <li>key={this.id}</li>
            </ul>
            <li>lifting state up: put state higher up in component hierarchy so multiple components have access to the same read only data (use prop from parent)</li>
            <li>use React.fragment or empty &lt;&gt;&lt;/&gt; (not supported everywhere) instead of div when returning only 1 element to prevent an extra unnecessary DOM node</li>
        </ul>
        <h3>State and Props</h3>
            <ul>
                <li>components can have 2 kinds of data</li>
                <ul>
                    <li>state data: stored locally within the component itself (can be changed)</li>
                    <li>prop data: stored in a parent component and passed down (read-only)</li>
                </ul>
                <li>to pass data out of a component, include the data as a custom attribute (ex.number) when rendering the component in another component</li>
                <li>state: class components can define a this.state object in constructor method to hold data for the component to use or pass down to child components as props</li>
                <ul>
                    <li>should never be assigned anywhere except in constructor, if elsewhere, use this.setState method to change</li>
                </ul>
                <li>props: objects in React used by components to receive data from parent components</li>
                <li>can pass multiple props to render (ex.greeting)</li>
                <img src="img/react-state-and-props.png" alt="">
            </ul>
    <h2>Object Destructuring</h2>
        <ul>
            <li>shortcut for accessing properties inside objects or items inside arrays then assigning them as values of new variables</li>
            <li>syntax</li>
            <ul>
                <li>const {property1, property2} = someObject</li>
                <li>function someFunction({property1, property2}) {}</li>
            </ul>
            <li>example 1</li>
            <ul>
                <li>const hotel = {<br> id: 0,<br>city: "Honolulu"<br>}</li>
                <li>instead of:</li>
                <li>const id = hotel.id<br>const city = hotel.city</li>
                <li>can use:</li>
                <li>const {id, city} = hotel</li>
            </ul>
            <li>example 2</li>
            <ul>
                <li>instead of:</li>
                <li>function hotelInfo(hotel) {<br>const id = hotel.id<br>const city = hotel.city<br>console.log(`${hotel.id} ${hotel.city}`)<br>}</li>
                <li>can use:</li>
                <li>function hotelInfo({id, city}) {<br>console.log(`${hotel.id} ${hotel.city}`)<br>}</li>
            </ul>
        </ul>
    <h2>React Component Types</h2>
        <ul>
            <li>Presentational and Container Components</li>
                <ul>
                    <li>presentational: renders UI based on props passed to them (don't usually maintain their own state beyond some light UI state)</li>
                    <li>container: fetches and manages state data to pass to presentational components for rendering</li>
                </ul>
        </ul>
    <h2>React Router</h2>
        <h3>React Virtual DOM</h3>
            <ul>
                <li>Browser DOM</li>
                <ul>
                    <li>the DOM is an API (application programming interface)- set of specifications for how programming languages and HTML interact with each other</li>
                    <li>maps HTML elements to a node-based, tree-like representation that programming languages can understand, traverse, and modify</li>
                    <li>when browser DOM is recreated, graphical view re-renders every time, so process can be "expensive"</li>
                </ul>
                <li>Virtual DOM</li>
                <ul>
                    <li>React is 1 implementation of the virtual DOM technique</li>
                    <li>React maintains a lightweight representation of the browser DOM which is faster and easier to update plus doesn't re-render the graphical display</li>
                    <li>DOM changes are first made in the virtual DOM</li>
                    <li>reconciliation (engine: Fiber): finds differences between virtual and browser DOM then finds best way to change the browser DOM</li>
                    <li>the reason why we use setState to change the state rather than changing it directly</li>
                    <li>the reason we use key attributes on list elements: helps reconciliation process</li>
                </ul>
            </ul>
        <h3>React Router</h3>
            <ul>
                <li>can use React to built a Single Page App (SPA) which launches from a single HTML page instead of having multiple HTML pages</li>
                <li>React Router- routing library that includes collection of router, route matching, and navigation components</li>
                <ul>
                    <li>handles routing requests to navigate to different views</li>
                    <li>generates unique, bookmarkable URL for each view</li>
                    <li>handles browser history (ability to move back and forward)</li>
                </ul>
                <li>react router components</li>
                <ul>
                    <li>&lt;BrowserRouter/&gt; top-level parent component that wraps around all other React-Router components (uses HTML5 history API to control browser history)</li>
                    <li>&lt;Route/&gt; renders UI for a matching path (use the attribute exact to get an exact match</li>
                    <ul>
                        <li>If just routing to component without passing state datea, use component={}</li>
                        <li>if need to pass state data as props to the component you're routing to, use render={}</li>
                    </ul>
                    <li>&lt;Redirect/&gt; redirects to a new URL</li>
                    <li>&lt;Switch/&gt; groups &lt;Route/&gt; components together</li>
                    <ul>
                        <li>works like switch from JS, will look through each case (route path) and if there is no match, then go to default (redirect)</li>
                    </ul>
                    <li>&lt;Link/&gt; creates links to a path (use instead of &lt;a&gt;)</li>
                    <li>&lt;Navlink/&gt; version of &lt;Link/&gt; that adds styles to active link</li>
                </ul>
            </ul>
        <h2>Single Page Application (SPA)</h2>
            <ul>
                <li>multi-page website: code is re-rendered and new server request every time you go to a new page</li>
                <li>SPA: front-end code is locally downloaded, when switching views app re-renders only changes and makes minimal server requests (ex. database data)</li>
                <ul>
                    <li>PROS: faster because less server requests, streamlined development, can reuse back end code for mobile app, easy to debug in browser</li>
                    <li>CONS: search engines can have trouble indexing, dependent on JS being enabled in browser, intial download can be slow, does not use traditional browser navigation (need React Router)</li>
                </ul>
            </ul>
        <h2>JS ES6 Computed Property Names, Spread Syntax, and Ternary Operator</h2>
            <ul>
                <li>computed property names: can pass in variables to use as property names when initializing an object (can create objects dynamically)</li>
                <li>example</li>
                <pre>
                    const myProperty = `foo`
                    const myObject = {
                        [myProperty] = `test`
                    }
                    myObject = {foo: `test`}
                </pre>
            </ul>
            <ul>
                <li>spread syntax: use to pull out/spread a copy of what is inside an array or object (can be used to create a new array or object)</li>
                <li>combining 2 arrays</li>
                <pre>
                    const arr1 = [`red`, 1];
                    const arr2 = [`blue`, 3];
                    const arr1and2 = [...arr1, ...arr2];
                    arr1and2 = [`red`, 1, `blue`, 3]
                </pre>
                <li>combining string to array</li>
                <pre>
                    const arr3 = [...arr1, `purple`];
                    arr3 = [`red`, 1, `purple`];
                </pre>
                <li>combining 2 objects (order it is combined matters)</li>
                <pre>
                    const obj1 = { color: `red`, width: 1 };
                    const obj2 = { color: `blue`, height: 3 };
                    const obj1and2 = { ...obj1, ...obj2 };
                    obj1and2 = { color: `blue`, width: 1, height: 3 }
                </pre>
            </ul>
            <ul>
                <li>ternary operator: shortcut for <code>if statement</code></li>
                <li><code>condition ? expression if truthy : expression if falsy</code></li>
                <pre>
                    function canVote(age) {
                        if (age >= 18) {
                            console.log(`can vote`)
                        } else {
                            console.log(`can not vote`)
                        }
                    }
                </pre>
                <pre>
                    function canVote(age)
                        age >= 18 ? console.log(`can vote`) : console.log(`can not vote`)
                </pre>
            </ul>
        <h2>React Forms</h2>
            <h3>Controlled Forms</h3>
                <ul>
                    <li>HTML form values directly tied to the state of its React component</li>
                    <li>single source of truth: React controls the form state to prevent conflicts</li>
                    <li>any changes to form fields immediately reflected in component's state and can be responded to with JS (ex. form validation and error messages)</li>
                    <li>require a lot of initial setup</li>
                </ul>
            <h3>Uncontrolled Forms</h3>
                <ul>
                    <li>HTML form states are tracked by the DOM and React retrieves data as needed</li>
                    <li>single source of truth: form elements within the DOM</li>
                    <li>alternative to controlled forms with quicker setup and easier if integrating React code with non-React code</li>
                    <li>use <code>ref</code>s to retrieve data or in Reactstrap- <code>innerRef</code></li>
                </ul>
        <h2>React Design Patterns</h2>
            <h3>MVC Design Pattern</h3>
                <ul>
                    <li>software design pattern to structure applications and develop presentation layer/client-side</li>
                    <li>separation of concerns: facilitates independent development, testing, maintenance of different parts of an app</li>
                    <li>3 parts: model, view, controller</li>
                    <ul>
                        <li>model: handle application state and logic</li>
                        <ul>
                            <li>code that retrieves data from database, stores it in application state, and updates it</li>
                            <li>responds to queries about state (from view/controller) and responds to requests to update state (from controller)</li>
                            <li>also notifies view and controller when state changes</li>
                        </ul>
                        <li>view: present info to user</li>
                        <ul>
                            <li>renders model into display (ex. UI element)</li>
                            <li>queries model directly about state and updates itself based on changes</li>
                        </ul>
                        <li>controler: mediate between model and view</li>
                        <ul>
                            <li>receive and process info from the view (ex. events, submissions)</li>
                            <li>instruct model and view to update</li>
                        </ul>
                    </ul>
                </ul>
            <h3>Flux</h3>
                <ul>
                    <li>MVC didn't scale well for large apps because of bi-directional data flow</li>
                    <li>Flux similar to MVC but unidirectional data flow</li>
                    <li>4 parts: action, dispatched, store, view</li>
                    <ul>
                        <li>action: when an action enters the system, it goes to the dispatcher</li>
                        <li>dispatcher: only 1 that acts as traffic controller and routes actions to stores</li>
                        <ul>
                            <li>makes sure that actions are processed one at a time to prevent cascading effects</li>
                        </ul>
                        <li>store: multiple that are registered with dispatcher and holds application state and logic</li>
                        <li>view: updates when stores are changed</li>
                        <ul>
                            <li>when another action enters the system from the view (ex. user interaction), sent to dispatcher</li>
                        </ul>
                    </ul>
                </ul>
            <h3>Redux</h3>
                <ul>
                    <li>Flux by itself is an architecture/design pattern with no actual code, but a JS library that implements code written with the Flux pattern is Redux</li>
                    <li>Redux: provides code that stores application state and a consistent way to access and update that state from anywhere in the app</li>
                    <li>fundamental principles: single source of truth, state is read-only, changes are made with pure functions</li>
                    <ul>
                        <li>single source of truth: only 1 store which holds a single state object tree (data structure with each node containing an object (like DOM)) that contains the whole state of the entire application as objects within that tree</li>
                        <li>state is read-only: only way to change state is with an action (an object that describes what happened)</li>
                        <li>changes are made with pure functions: pure functions (aka reducers) have no side effects and given the same inputs, will always return the same outputs (ex. Math.floor() is a pure function, Math.random() is an impure function)</li>
                        <ul>
                            <li>reducer: pure function that takes the previous state and an action and returns the next state (like .map, returns new state object without mutating previous state)</li>
                            <li>new objects are "cheap" to make and allows time travel (ability to step back and forth from previous state (ex. like flipbook))</li>
                        </ul>
                        <li>4 parts: action, reducer, store, view</li>
                    </ul>
                </ul>
                <h4>React-Redux library</h4>
                    <ul>
                        <li><code>createStore()</code>: creates Redux store which holds the state as an object tree</li>
                        <li><code>connect()</code>: generates container component that wraps around other components to subscribe them to the store</li>
                        <li><code>mapStateToProps()</code>: passed as callback to <code>connect()</code> function, called whenever state changes, receives entire state tree, and returns object containing only the data needed by the component</li>
                        <li><code>&lt;Provider&gt;</code>: wraps around root component of the app (App), takes store variable as attribute, makes store accessible to all child components that are connected using <code>connect()</code> function</li>
                    </ul>
    <h2>Redux Actions and Reducers</h2>
        <ul>
            <li>Actions</li>
            <ul>
                <li>JS objects that contain info updates sent to Redux store</li>
                <li>only required property: <code>type</code> (will be a unique string)</li>
                <li>best practice: gather all action types into a separate module (easily see all the action types)</li>
            </ul>
            <li>Dispatching an action</li>
            <ul>
                <li>1) action &#8594; 2) create action type &#8594; 3) create action creator &#8594; 4) connect action to React component</li>
                <li>components dispatch an action in response to user interaction (ex. loading new view, clicking a button)</li>
                <li>action type defined as a string constant (<code>ActionTypes.ADD_CAMPSITES</code>)</li>
                <li>action creator: function that returns the action object and has a <code>type</code> property plus any data (payload) to send to store to update (ex. const addCampsites)</li>
                <li>then connect each action to a React component using <code>connect()</code> function and <code>mapDispatchToProps</code></li>
                <pre>
                export const addCampsites = campsites => ({
                    type: ActionTypes.ADD_CAMPSITES,
                    payload: campsites
                })
                </pre>
            </ul>
            <li>Reducers</li>
            <ul>
                <li>5) Redux store checks all reducers for matching action type &#8594; 6) run code for that action type &#8594; 7) update the state</li>
                <pre>
                export const Campsites = (states = {campsites: []}, action) => {
                    switch (action.type) {
                        case ActionTypes.ADD_CAMPSITES:
                            return {...state, campsites: action.payload}
                        default:
                            return state
                    }
                }
                </pre>
                <li>takes in state as 1st argument (if state doesn't exist yet, then default campsites object with empty array) and action object that was dispatched as 2nd argument</li>
                <li>if any of the action.types match the switch statement, then will use spread syntax to update state with new payload from action then return new state object to the store</li>
                <li>if no action.types match, default return original state</li>
            </ul>
            <li>Splitting the reducer</li>
            <ul>
                <li>can have multiple reducers in separate files, but Redux store only takes 1 reducer as an argument so can use <code>combineReducer</code> to create root reducer to use with <code>createStore()</code></li>
            </ul>
        </ul>
        <h2>Redux Middleware</h2>
            <ul>
                <li>intercepts an action after it is dispatched and before it reaches reducer to change it or cause a side effect other than updating the state (ex. logging, waiting for server response)</li>
                <ul>
                    <li>ex. third party extension library Redux logger, shows every single action that is dispatched in console with its previous, current action, and next state with new action</li>
                </ul>
                <li>synchronous vs asynchronous</li>
                <ul>
                    <li>synchronous code: everything happens in order and app waits until a piece of code is finished processing before continuing</li>
                    <li>asynchronous code: start processing, then continue with app without waiting for it to finish, and deal with results later</li>
                    <ul>
                        <li>common use: client requests data from server (need to wait for response before using the data)</li>
                    </ul>
                </ul>
                <li>use middleware to wrap around dispatch and insert operations before action reaches reducer (ex. making async calls, crash reporting, stopping an action, dispatching other actions)</li>
                <li>can chain middleware to have multiple libraries used in sequence</li>
                <li><code>applyMiddleware()</code> function passed as a parameter to <code>createStore()</code></li>
            </ul>
            <h3>Redux Thunk</h3>
                <ul>
                    <li>thunk: programming technique that wraps a function inside another function to delay its execution or dispatch only if a certain condition is met</li>
                    <li>Redux Thunk: uses thunk to inject extra operations into an action creator which normally returns an action object to instead return a function</li>
                </ul>
        <h2>Client-Server Communication</h2>
            <h3>Networking between web browsers and web servers</h3>
                    <li>communication between front end & back end</li>
                    <ul>
                        <li>back end of apps usually hosted on servers of cloud platforms (AWS, Heroku, DigitalOcean, Microsoft Azure)</li>
                        <li>when an app in the browser wants to communicate with any server, there may be delays or errors that need to be handled by front-end to let user know what is happening</li>
                    </ul>
                    <li>Network protocols</li>
                    <ul>
                        <li>set of rules for how 2 networked systems talk to each other</li>
                        <li>ex of rules: type of data exchanged, how data is formatted, how systems respond to certain request types, etc</li>
                        <li>lots of network protocols that work at different network layers (from physical to application layer)</li>
                    </ul>
                    <li>HTTP (HyperText Transfer Protocol</li>
                    <ul>
                        <li>application layer protocol that is the foundation of data communication on the web</li>
                        <li>browser sends HTTP request to server</li>
                        <ul>
                            <li>always supplies HTTP method (aka action aka verb) (ex. GET/PUT/POST/DELETE)</li>
                            <li>HTTP protocol version (usually 1.1)</li>
                            <li>URL (uniform resource locator)</li>
                            <li>header (optional)</li>
                            <li>body (if there is one- usually none in GET request, but one in POST)</li>
                        </ul>
                        <li>server sends back HTTP response</li>
                        <ul>
                            <li>HTTP status code range from 1-500 (ex. 200, 302, 404)</li>
                            <li>HTTP protocol version (usually 1.1), header (optional), body (if there is one- usually none in GET request, but one in POST)</li>
                        </ul>
                    </ul>
                    <li>Transferring data: JSON vs XML</li>
                    <ul>
                        <li>2 common ways to format text data files</li>
                        <li>JSON: Javascript Object Notation</li>
                        <ul>
                            <li>syntax is similar to JS object, easy to convert JSON to and from JS objects so use this file format to encode data for transferring over networks to let JS apps and databases easily parse</li>
                            <li>typically used with RESTful web services</li>
                        </ul>
                        <li>XML: eXtensible Markup Language</li>
                        <ul>
                            <li>syntax is similar to HTML, like JSON used to store and transfer text data</li>
                            <li>typically used with protocal called SOAP</li>
                        </ul>
                    </ul>
                </ul>
            <h3>REST</h3>
                <ul>
                    <li>REST (representational state transfer): software architetural style that defines a set of constraints for creating web services</li>
                    <li>web services: resources available over the web (2 types: SOAP & RESTful)</li>
                    <li>SOAP (simple object access protocol): protocol with strictly defined rules
                        <ul>
                            <li>uses WSDL (web services description language) to specify how 2 endpoints in a network communicate with each other</li>
                            <li>depends on XML for messaging format</li>
                        </ul>
                    <li>REST: approach with no exact specifications</li>
                    <ul>
                        <li>can use XML, HTML, plain text, or JSON for messaging format</li>
                        <li>6 defining constraints of REST</li>
                        <ol>
                            <li>client-server separation: client and server can be implemented separately as long as the interface stays consistent (dividing UI and data storage concerns improves flexibility and scalability)</li>
                            <li>statelessness: server doesn't store info about client's state after communication is completed (client responsible for tracking its own state)</li>
                            <li>uniform interface: resources exposed to server must have a single URI (uniform resource identifier), done with directory-like style (ex. react-router)</li>
                            <li>cacheable: clients can cache responses & server responses contain info on how to cache and if they should be cached</li>
                            <li>layered system: layers between client and server (maybe intermediary server that caches data being requested)</li>
                            <li>code on demand: (optional) servers can temporarily extend functionality of client-side code by transferring executable code (ex. JS)</li>
                        </ol>
                        <li>9 HTTP methods- first 4 analogous to CRUD (Create/Read/Update/Delete)</li>
                        <ol>
                            <li>POST: create new resource on the server</li>
                            <li>GET: request a resource from the server</li>
                            <li>PUT: update a resource on the server</li>
                            <li>DELETE: delete a resource on the server</li>
                            <li>HEAD</li>
                            <li>CONNECT</li>
                            <li>OPTIONS</li>
                            <li>TRACE</li>
                            <li>CATCH</li>
                        </ol>
                        <li>all 4 but POST are idempotent: when an operation can be repeated multiple times and doesn't change its operand more than once (if at all) (ex. multiplying by 0)</li>
                        <ul>
                            <li>each POST request will be different, but GET, PUT, and DELETE will be the same after repetitions</li>
                        </ul>
                        <li>resource on server: any data that can be requested by a client (ex. name from database, stock price, weather report, image, HTML file)</li>
                        <ul>
                            <li>resources available at uniqure URIs and client and request each resource specifically by its URI</li>
                            <li>client and server don't send resources to each other, but representations of resources (usually as JSON or XML) which is then converted to resources (Representational State Transfer)</li>
                            <li>server responds to GET request for resource by sending a representaiton of the resource</li>
                            <li>OR client sends POST or PUT request by sending representation in request body, and server creates a resource from it</li>
                        </ul>
                    </ul>
</body>
</html>